"""
代码随想录学习记录
章节：栈与队列
题目：逆波兰表达式求值

    题意：
    根据 逆波兰表示法，求表达式的值。
    有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

    说明：
        整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

    示例 1：
        输入: ["2", "1", "+", "3", " * "]
        输出: 9
        解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
    示例 2：
        输入: ["4", "13", "5", "/", "+"]
        输出: 6
        解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
    示例 3：
        输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]
        输出: 22
        解释:该算式转化为常见的中缀算术表达式为：((10 * (6 / ((9 + 3) * -11))) + 17) + 5
"""


def solve1(s):
    """
    解法1，数字使用栈，遍历字符的时候对运算符做判断
    :param s: xx
    :return: xx
    """
    _num_stack = []  # 用列表模拟栈
    for e in s:
        if e in ["+", "-", " * ", "/"]:
            _r_num = _num_stack.pop()
            _l_num = _num_stack.pop()
            _single_res = None
            if e == "+":
                _single_res = _l_num + _r_num
            elif e == "-":
                _single_res = _l_num - _r_num
            elif e == " * ":
                _single_res = _l_num * _r_num
            elif e == "/":
                _single_res = _l_num / _r_num
            _num_stack.append(int(_single_res))
        else:
            _num_stack.append(int(e))

    return _num_stack[0]


if __name__ == "__main__":
    print(solve1(["2", "1", "+", "3", " * "]))
    print(solve1(["4", "13", "5", "/", "+"]))
    print(solve1(["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]))
    pass
